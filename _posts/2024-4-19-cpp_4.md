---
layout: article
title: C++ 编译
key: 100001
tags: C++ 编译
category: blog
date: 2024-04-19 15:20:13 +08:00
mermaid: true
---


  | 类别 | 问题 | 
  |---|---|
  | C++关键字 | ++i与i++的不同 |
  | C++关键字 | NULL和nullptr的不同 |
  | C++关键字 | include<> 和 include ""的不同 |
  | C++关键字 | inline的优缺点 |
  | C++关键字 | 虚函数是否可以是inline |
  | C++关键字 | class与struct的默认继承方式 |
  | C++关键字 | 不能继承的类或函数 |
  | C++关键字 | 类与类之间关系 |
  | C++关键字 | 继承控制方式对属性的影响 |
  | C++关键字 | 组合 |
  | C++关键字 | 多态原因 |
  | C++关键字 | 多态类型 |
  | C++关键字 | 多态实现 |


## C++关键字

### ++i与i++的不同

  ++i 不会产生临时对象，i++ 产生临时对象，会导致效率降低

  **++i**

  ```c++
  int& int::operator++ (){
  *this +=1;
  return *this;
  }
  ```

  **i++**

  ```c++
  const int int::operator(int){
  int oldValue = *this;
  ++(*this);
  return oldValue;
  }

  ```

  
### NULL和nullptr的不同

 **NULL特点**
  在c++与c中，使用NULL代表0或void*，但可能会产生类型不匹配的警告或错误

  ```c++
  #ifdef __cplusplus
  #define NULL 0
  #else
  #define NULL ((void*)0)
  #endif
  ```

 **nullptr特点**
  * 为解决NULL的二义性，使用nullptr替代空指针，对应参数为 void*


### inline的优缺点

 只是对编译器的建议，编译器会根据实际情况决定是否将函数内联

 **inline优点**
  * 函数调用开销：内联函数在编译时将函数体直接插入到每个调用点，从而避免了函数调用的开销，如参数传递、栈帧创建和销毁等。这有助于提高程序的执行效率，特别是在函数体较小且调用频繁的情况下。
  * 类型检查：与宏相比，内联函数在展开时会进行类型检查和语法分析，从而提供了更好的类型安全性。这有助于减少因类型不匹配或语法错误而导致的运行时错误。
  * 内联函数与普通函数一样具有函数名和参数列表，这使得代码更具可读性。同时，它还可以访问类的私有和保护成员，提供了更灵活的使用方式。

 **inline缺点**
  * 由于内联函数的代码会在每个调用点展开，因此可能导致代码体积增大，这可能导致可执行文件的大小增加。对于大型程序或库来说，这可能成为一个问题。
  * 由于内联函数的代码需要在每个调用点展开，这可能导致编译时间增加。特别是在大型项目中，这种影响可能更加明显
  * 对于代码较长或包含循环的函数，内联可能导致性能下降，因为函数体展开后的代码可能比函数调用本身更耗时
  * 函数频繁修改，需要重新编译所有调用该函数的地方

 **虚函数是否可以为inline**
  * 无多态：虚函数只有在编译器知道所调用的对象是哪个类才可，但将虚函数设置为inline并不会提高执行效率；
  * 有多态：表现多态是不可内联



### auto

 **目的**
  * 自动类型推导：当编译器能够自动确定变量的类型时，使用 auto 来声明，而不需要指定类型。使代码更简洁，尤其是在处理复杂类型或模板编程时
  * 可维护性：但需要权衡可维护性与可读性

 **应用**
  * 可以推断基本类型
  * 可以推断引用类型: 

  ```c++

  auto& ref = x; 
  const int ci = 10; 
  const auto c2 = ci;

  ```
  * **推断发生在编译期**，所以使用auto并不会造成程序运行时效率的降低。

### decltype
 **目的**
  * 为了解决复杂的类型声明而使用的关键字
 
 **应用**
  * 多出现在泛型编程，编译期间确定

 **decltype(c)**
  * 若 e 为⼀个⽆括号的变量、函数参数、类成员，则返回类型为该变量/参数/类成员在源程序中的声明类型
  * 否则的话，根据表达式的值分类
    * 若 e 是⼀个左值，即可寻址的，返回 T& ；
    * 若 e 是⼀个临终值，则返回值为 T&& ；
    * 若 e 是⼀个纯右值，则返回值为 T 。
```c++
const std::vector<int> v(1);
const int&& foo(); // 返回临终值：⽣命周期已结束但内存还未拿⾛
auto a = v[0]; // a 为 int
decltype(v[0]) b = 0; // b 为 const int&
 // 即 vector<int>::operator[](size_type) const 的
返回值类型
auto c = 0; // c, d 均为 int
auto d = c; 
decltype(c) e; // e 为 int，即 c 的类型
decltype((c)) f = e; // f 为 int&，因为 c 是左值
decltype(0) g; // g 为 int，因为 0 是右值
```

### explicit

 **目的**
  * 防止隐式转换

 **应用**
  * 应用于仅含有一个参数，或除第一个参数外，其他参数都有默认值的构造函数


### friend

 **友元函数**
  * 使得普通函数直接访问类的保护数据和私有数据成员，避免了类成员函数的频繁调用，可以节约处理器开销，提高程序的效率
  * 编译期间确定
 
 **使用注意**
  * 当某类函数需要另外一个类的私有成员，在另外那个类声明friend，并引入需要私有成员的类`friend int B::func(A& a)`
  * 在需要类成员的类中声明`int func(A& a)`
  * 最后在类外实现方法`int B::func(A& a)`

 **友元类**
  * 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息




### 结构体
 为内存对齐后的结果
 成员对齐、整体对齐
 **定义**
  * **不同类型**的数据组成整体


 **特点**
  * 每个成员都有自己的独立地址
  * **sizeof**之后是内存对齐之后所有成员的长度和


 **struct与数组**
  * 原因：数组空间有限，有些数组需要动态分配空间，编译期间初始化无法得到数组的长度
    * 在结构体和类中定义空数组，其数组内容不占用struct空间，可以在最后分配malloc中直接分配动态buffer，`malloc(sizeof(struct()+buff.size()))`
  * 特点
    * 不定长数组只能作为结构体的最后一个成员出现，只能有一个不定长数组。
    * 不定长数组不能被初始化，只能在运行时动态分配和释放内存空间。


### 共同体
 **定义**
  * 各成员共享一段内存空间，大小为成员中最长成员的长度


 **特点**
  * 共享内存可以将变量付给任一成员，但每次只能赋一种值，会覆盖



### 字节对齐
 **引入原因**
  * CPU访问数据效率问题，对于0-7存储的变量读取只需要一次，否则需要两次


 **对齐规则**
  * x86 -> GCC默认4字节对齐
    * 可以使用`__attribute__`选项改变对齐规则
  * vs中使用`#pragma pack (n)`改变


 **常见变量字节数**
  
  | type                       | bytes                             |
  | -------------------------- | --------------------------------------- |
  | char                   | 1                                       |
  | short               | 2                                       |
  | int                | 4                     |
  | double               | 8                                     |
  | int b[0]                     | 0                                       |


 **struct对齐**
  * 对char、char、int类型有8个bytes
  * 对char[5]、short、int类型有12个bytes
  * 对char、double、char类型有24个bytes
  * 数组`int[]`或`int[0]`指向前一个位置，本身不占空间
    * char、int、int[]有8个bytes
    * int[]占用4个bytes
    * 空结构体占用1 bytes


