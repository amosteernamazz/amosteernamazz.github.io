---
layout: article
title: C++多态
key: 100002
tags: C++ 多态
category: blog
date: 2024-04-22 14:54:38 +08:00
mermaid: true
---



  | 类别 | 问题 | 
  |---|---|
  | 与其他语言的区别 | 与C区别 |
  | 与其他语言的区别 | 与Java区别 |
  | 封装、继承与多态 | 封装原因 |
  | 封装、继承与多态 | 继承原因 |
  | 封装、继承与多态 | 继承缺点 |
  | 封装、继承与多态 | class与struct的默认继承方式 |
  | 封装、继承与多态 | 不能继承的类或函数 |
  | 封装、继承与多态 | 类与类之间关系 |
  | 封装、继承与多态 | 继承控制方式对属性的影响 |
  | 封装、继承与多态 | 组合 |
  | 封装、继承与多态 | 多态原因 |
  | 封装、继承与多态 | 多态类型 |
  | 封装、继承与多态 | 多态实现 |

## 动态virtual

 动态多态通过继承+虚函数实现


 **原理**

 ![](https://github.com/amosteernamazz/amosteernamazz.github.io/raw/master/pictures/cppdy_1.png)

  * 对象中有**虚函数的指向的指向**（编译期间**创建对象**或运行时创建对象时创建）和虚函数表（每个**类的虚函数入口地址**，为**编译期**创建）

  * 管理对象的空间中有vptr地址（随对象创建而创建），vptr指针对应的vtable（在编译期确定，是针对类的）中保存该对象的虚函数成员，其保存函数的入口地址


 **多继承**
  * 在多继承中，vtable会有多个vptr地址，对应不同基函数的vptr


 **运行时virtual**
  * 为了多态，编译器会给每个包含虚函数或继承了虚函数的类自动建立一个虚函数表，当子类继承父类的虚函数时，子类会有自己的vtable
    * 如果存在**大量的子类继承**，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费


 **多态的实现原理（为什么构造和析构需要按顺序）**

  [虚表的写入时机、多态的实现原理、构造析构顺序的原因](https://blog.csdn.net/weixin_43919932/article/details/104356460)

 ![](https://github.com/amosteernamazz/amosteernamazz.github.io/raw/master/pictures/cppdy_2.png)



 **构造函数与virtual**

  构造函数是否可以为virtual
  * 不能
  * 虚函数调用需要对象构建得到虚表调用，而对象还没有构造。

  构造函数中调用virtual
  * 首先创建派生类的基类部分，执行基类构造，由于派生类没有初始化，所以c++当作不存在，仅仅将其认为是基类的对象。


 **析构函数与virtual**
 
  析构函数的子类应该声明为virtual
  * 为了确保析构的时候，释放派生类对象，需要基类析构函数声明为虚函数，否则只会析构对应的父类对象，而不会析构子类对象。
  析构函数中调用virtual
  * 仅仅将其认为是基类的对象。


 **哪些函数不能是虚函数**
  * 构造函数
  * 某些析构函数
  * 友元函数（原因不是类成员）
  * 静态成员函数（原因：不属于任何对象或实例）
  * 内联函数（原因：需要在编译期间展开，同时需要类对象有vptr，但没有地址）
  * 成员函数模板（原因：成员模板函数需要在调用的时候才能确定，而虚函数需要解析时候确定vtable大小）


## 纯虚函数
 **区别**
  * 纯虚函数用于如果生成基类对象则不合理的场景
  * 其使得纯虚函数的类为抽象基类，本身成为了接口


 **使用**
  `virtual void exit()=0`=0表示为纯虚函数
