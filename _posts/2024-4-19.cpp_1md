---
layout: article
title: C++封装继承与多态
key: 100001
tags: C++
category: blog
date: 2024-04-19 15:20:13 +08:00
mermaid: true
---



  | 类别 | 问题 | 
  |---|---|
  | 与其他语言的区别 | 与C区别 |
  | 与其他语言的区别 | 与Java区别 |
  | 封装、继承与多态 | 封装原因 |
  | 封装、继承与多态 | 继承原因 |
  | 封装、继承与多态 | 继承缺点 |
  | 封装、继承与多态 | class与struct的默认继承方式 |
  | 封装、继承与多态 | 不能继承的类或函数 |
  | 封装、继承与多态 | 类与类之间关系 |
  | 封装、继承与多态 | 继承控制方式对属性的影响 |
  | 封装、继承与多态 | 组合 |
  | 封装、继承与多态 | 多态原因 |
  | 封装、继承与多态 | 多态类型 |
  | 封装、继承与多态 | 多态实现 |

## 与其他语言的区别

### 与C区别

  | 区别 | C | C++
  |---|---|---|
  | 头文件 | .h | .h .hpp | 
  | 命名空间 | 不支持 | 支持 | 
  | 空间分配 | malloc、free、calloc、realloc | new、delete、malloc、free |
  | 引用 | 不支持 | 支持 |
  | struct | 仅为变量；为private；无法初始化、定义别名与使用模板 | 支持函数；为public；支持初始化、定义别名与使用模板 |
  | auto、explicit | 不支持 | 支持 |
  | 重载与虚函数 | 不支持 | 支持 |
  | dynamic_cast | 不支持 | 支持 |
  | 模板 | 不支持 | 支持、STL |

### 与Java区别

  | 区别 | Java | C++
  |---|---|---|
  | 指针 | 无法访问 | 支持访问 | 
  | 继承 | 不支持多重继承、但支持多个接口 | 支持多重继承，接口类似虚函数概念 | 
  | 函数与变量 | 除基本类型外，都是类的函数 | 支持类外函数与变量 |
  | struct与union | 不支持 | 支持 |
  | 内存管理 | 均为new出来的，回收自动 | 支持malloc、free、new、delete |
  | 操作符重载 | 不支持 | 支持 |
  | 预编译 | 不支持 | 支持 |
  | 字符串 | 类对象实现 | 结尾以null为终止符 |
  | 异常处理机制 | try-catch-finally、类型确定、无返回码 | try-catch、类型不确定、有返回码 |


## 封装、继承与多态

### 封装

 **封装原因**
  * 结合：将属性与方法结合；
  * 接口：利用接口机制隐藏内部实现细节，只留下接口供外部调用；
  * 复用：实现代码复用

### 继承

 **继承原因**
  * 接口：使用所有非私有方法
  * 复用：继承属性与方法，减少代码的书写
  * 重写：重写父类的方法以增加子类的功能


 **继承类型**
  * 单一继承：继承一个父类，最多使用
  * 多重继承：一个类有多个基类，类之间使用逗号隔开
  * 菱形继承：BC继承自A，D继承自BC


 **继承缺点**
  * 耦合：耦合性太大
  * 封装：破坏了类的封装性
  * 解决：使用抽象方法的继承和接口

<!--more-->

 **class与struct的默认继承方式**
  * class默认private继承
  * struct默认public继承


 **不能继承的类或函数**
  * final
  * 赋值运算符=
  * 友元类/友元函数不能继承
  * 虚继承
  * 构造函数
    * 列表初始化与默认构造：子类构造函数使用成员列表初始化来调用父类构造函数以创建派生类中的基类部分。如果子类没有使用成员列表初始化，默认使用默认基类构造函数，如果没有默认构造函数会报错。
    * 父类属性：在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有private属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。
  * 析构函数
  * 单例模式中将自身构造和析构放在private作用域中不能继承

 **类与类之间关系**
  * has：包含关系
  * use：friend关系
  * is：继承关系

 **继承控制方式对属性的影响**
  * public继承 -> 不改变基类的访问权限 
  * protected继承 -> 将父类public成员变为子类protected成员，其他保持不变
  * private继承 -> 不受继承方式的影响，子类永远无权访问

![](https://github.com/amosteernamazz/amosteernamazz.github.io/raw/master/pictures/c%2B%2B_1.png)

 **组合**

  * 定义：⼀个类⾥⾯的数据成员是另⼀个类的对象，即内嵌其他类的对象作为⾃⼰的成员
  * 组合对象的构建：⾸先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进⾏初始化，⼜要对内嵌对象进⾏初始化
  * 组合对象的构建顺序：先调⽤内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表顺序⽆关。然后执⾏组合类构造函数的函数体，析构函数调⽤顺序相反。


### 多态

 **多态原因**
  * 运行时的调用函数需要根据编译时类型决定程序最终执行过程的真实调用方法

 **多态种类**
  * 静态多态：编译期间确定。不需要基类，只需要在各个具体实现中要求相同的接口名称
    * 重载、模板函数
  * 动态多态：**继承+虚函数实现**。程序运行时确定。确定子父类共同功能，在父类中，将功能声明为虚函数，子类重写虚函数，完成具体功能
    * 虚函数、基类引用指向子类对象


 **多态实现**
  * 重载：编译期实现
  * 类、函数模板：编译期
  * 虚函数：运行期

