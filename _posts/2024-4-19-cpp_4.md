---
layout: article
title: C++ 编译
key: 100004
tags: C++ 编译
category: blog
date: 2024-04-19 15:20:13 +08:00
mermaid: true
---

  | 类别 | 问题 | 
  |---|---|
  | NULL和nullptr | NULL定义 |
  | NULL和nullptr | nullptr定义 |
  | inline | inline优缺点 |
  | inline | inline使用建议 |
  | inline | 虚函数是否可以为inline |
  | auto | auto优势 |
  | auto | auto注意事项 |
  | auto | auto可以推断类型 |
  | auto | auto不可以推断类型 |
  | friend | 友元函数 |
  | friend | 友元类 |
  | friend | 注意事项 |
  | 封装、继承与多态 | 多态实现 |


### NULL和nullptr

 **NULL**
  在c++与c中，使用NULL代表0或void*，但可能会产生类型不匹配的警告或错误

  ```c++
  #ifdef __cplusplus
  #define NULL 0
  #else
  #define NULL ((void*)0)
  #endif
  ```

 **nullptr**
  * 为解决NULL的二义性，使用nullptr替代空指针，对应参数为 void*


### inline

 * 建议编译器将函数体插入到每个调用点，而不是进行常规的函数调用。用于优化那些体积小、调用频繁的函数，减少函数调用开销。
 * 只是建议给编译器的提示，并不保证一定会被内联。编译器会根据优化策略来决定是否内联一个函数。

 **inline优点**
  * 减少函数调用开销，提高速度：内联函数在编译时将函数体直接插入到每个调用点，从而避免了函数调用的开销，如参数传递、栈帧创建和销毁等。这有助于提高程序的执行效率，特别是在函数体较小且调用频繁的情况下。
  * 类型检查：与宏相比，内联函数在展开时会进行类型检查和语法分析，从而提供了更好的类型安全性。这有助于减少因类型不匹配或语法错误而导致的运行时错误。
  * 内联函数与普通函数一样具有函数名和参数列表，这使得代码更具可读性。同时，它还可以访问类的私有和保护成员，提供了更灵活的使用方式。

 **inline缺点**
  * 代码量增大：由于内联函数的代码会在每个调用点展开，因此可能导致代码体积增大，这可能导致可执行文件的大小增加。对于大型程序或库来说，这可能成为一个问题。
  * 编译增加：由于内联函数的代码需要在每个调用点展开，这可能导致编译时间增加。特别是在大型项目中，这种影响可能更加明显
  * 内联函数不当设计：对于代码较长或包含循环的函数，内联可能导致性能下降，因为函数体展开后的代码可能比函数调用本身更耗时
  * 编译增加：函数频繁修改，需要重新编译所有调用该函数的地方
  * 滥用可能导致优化失败：不当使用内联可能会导致编译器无法进行其他有效的优化。


 **使用建议**
  * 小函数优先：对于只有几行代码的小函数，内联通常是有益的。但对于大函数，内联可能会导致代码膨胀和性能下降。
  * 不要过度使用：不要仅仅因为你想让函数更快就盲目地使用内联。应该基于性能分析和代码审查来决定是否使用内联。
  * 注意编译器优化：现代编译器通常能自动地识别并内联那些适合内联的小函数，所以有时候你不需要显式地使用 inline 关键字。

 **虚函数是否可以为inline**
  * 无多态：虚函数只有在编译器知道所调用的对象是哪个类才可，但将虚函数设置为inline并不会提高执行效率；
  * 有多态：表现多态是不可内联

### auto
 * auto 用于自动推断变量的类型。它让编译器根据初始化表达式的类型自动为变量选择正确的类型，主要适用于局部变量和临时变量，这些变量的类型通常可以在编译时根据初始化表达式明确推断出来
 
 **优势**
  * 代码简洁性：避免显式地写出变量的类型，代码更加简洁易读。
  * 泛型编程：在模板编程或处理容器、迭代器等泛型结构时，auto 可以自动推断出正确的类型，使代码更加灵活和易于编写。
  * 推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。

 **注意事项**
  * 必须初始化：使用 auto 声明的变量在声明时必须立即初始化，因为编译器是根据初始化表达式的类型来推断变量类型的。
  * 不要过度使用：虽然 auto 可以简化代码，但过度使用可能会使代码的可读性降低。在某些情况下，显式地写出变量的类型可能更有助于理解代码。

 **可以推断类型**
  * 基本类型，如int、double、char等
  * 引用、指针类型
  * 复合类型：例如数组、结构体、类实例等。
    * 对于数组，auto会推断出数组第一个元素的指针类型，而不是数组本身。
  * 模板类型：在模板编程中，auto可以推断出模板参数的类型。

 **不可以推断的类型**
  * 函数参数类型：函数参数的类型必须显式指定，auto不能用于推导函数参数的类型。
  * 非静态成员变量类型：auto是在编译时期进行推导的，因此不能用于推导类的非静态成员变量的类型，但一般静态成员变量也不用auto。
  * 顶层const：auto一般会忽略掉顶层const（即指针本身的常量性），但底层const（即指针指向的对象的常量性）会保留下来。
  * 数组类型：auto不能用于声明数组，因为数组类型不能出现在顶级类型中。
  * 模板参数实例化：auto不能作为模板参数进行实例化。


  ```c++
  // 引用
  int x = 10;
  auto& ref = x;
  ref = 20;

  // 指针
  int w = 10;
  auto ptr = &w;
  const int ci = 10;
  const auto c2 = ci;

  // const类型
  const int a = 10;
  auto b = a; // b被推导为int
  const auto c = a; // c被推导为const int

  const int x = 20;  
  const int* ptr1 = &x;  // ptr1 为const int* 类型
  auto ptr2 = ptr1; // ptr2 为const int* 类型
  const auto ptr3 = ptr1; // ptr1 为const int* 类型
  ```


### friend

 * 允许一个函数或类访问另一个类的私有（private）或保护（protected）成员，即使这些成员在通常情况下是不可访问的

 **友元函数**
  * 当一个函数被声明为另一个类的友元（friend），那么这个函数就可以访问该类的所有成员，包括私有和保护成员。
 
 ```c++
 class MyClass {
private:
    int secret;

public:
    MyClass(int val) : secret(val) {}

    // 声明 friend 函数
    friend void revealSecret(const MyClass& obj);
};

// friend 函数实现
void revealSecret(const MyClass& obj) {
    std::cout << "The secret is: " << obj.secret << std::endl;
}

int main() {
    MyClass myObj(42);
    revealSecret(myObj);  // 输出: The secret is: 42
    return 0;
}
 ```

**友元类**

```c++
class MyClass {
private:
    int secret;

public:
    MyClass(int val) : secret(val) {}

    // 声明另一个类为 friend
    friend class MyFriendClass;
};

class MyFriendClass {
public:
    void revealSecret(const MyClass& obj) {
        std::cout << "The secret is: " << obj.secret << std::endl;
    }  
};  
  
int main() {
    MyClass myObj(42);
    MyFriendClass friendObj;
    friendObj.revealSecret(myObj);  // 输出: The secret is: 42
    return 0;
}
```

 **使用注意**
  * 谨慎使用：friend关键字破坏了封装性，使得原本不应该被外部访问的私有成员变得可访问。因此，应该谨慎使用
  * 单向关系：友元关系是单向的。如果类A将类B声明为友元，那么类B可以访问类A的私有成员，但类A不能访问类B的私有成员，除非类B也将类A声明为友元。
  * 非传递性：友元关系不是传递的。如果类A是类B的友元，类B是类C的友元，那么类A不一定是类C的友元。
  * 非继承性：友元关系不会被子类继承。如果类A是类B的友元，而类C是类B的子类，那么类A不一定是类C的友元。





### explicit

 * 主要用于修饰只有一个参数的类构造函数，目的是防止该类对象进行不期望的隐式转换。

 **应用**
  * 当定义了只有一个参数的类构造函数时，构造函数除了构造对象外，还被编译器用于进行隐式类型转换。可能会导致一些不期望的行为或错误。使用 explicit 关键字可以明确地告诉编译器，我们不希望进行这种隐式转换。

```c++
class Foo {  
public:  
    Foo(int value) {  
        // ... 构造函数的实现 ...  
    }  
};  
  
void takeFoo(Foo foo) {  
    // ... 函数实现 ...  
}  
  
int main() {  
    int x = 10;  
    takeFoo(x);  // 这里会隐式调用 Foo(int value) 构造函数  
    return 0;  
}
```

```c++
class Foo {  
public:  
    explicit Foo(int value) {  
        // ... 构造函数的实现 ...  
    }  
};  
  
void takeFoo(Foo foo) {  
    // ... 函数实现 ...  
}  
  
int main() {  
    int x = 10;  
    takeFoo(x);  // 这里会编译错误，因为 Foo(int value) 构造函数是 explicit 的  
    return 0;  
}
```

### final

 **防止类被继承**
  
  ```c++
  class Base final {  
public:  
    void foo() {  
        // ...  
    }  
};  
  
class Derived : public Base { // 错误！不能从final类继承  
public:  
    void bar() {  
        // ...  
    }  
};
  ```

 **禁止虚函数被重写**

```c++
class Base {  
public:  
    virtual void foo() final {  
        // ...  
    }  
};  
  
class Derived : public Base {  
public:  
    void foo() override { // 错误！不能重写final虚函数  
        // ...  
    }  
};
```

### override

* 类的成员函数声明中明确函数是为了重写基类中的虚函数。
* override 可以帮助编译器在编译时检查是否正确地重写了基类中的虚函数，如果基类中没有相应的虚函数，编译器会报错。

**override优势**
  * 提高代码可读性：通过在派生类中使用 override 关键字，可以清晰地表明该成员函数是为了重写基类中的虚函数。
  * 编译时检查：编译器会检查基类是否确实有一个虚函数与派生类中的函数具有相同的签名。如果没有，编译器会报错，这有助于早期发现错误。
  * 防止意外重载：有时候，由于函数签名的不匹配（例如参数类型或数量的不同），我们可能无意中重载了基类的虚函数而不是重写它。使用 override 可以避免这种情况。

```c++
class Base {  
public:  
    virtual void func() {  
        std::cout << "Base::func()" << std::endl;  
    }  
};  
  
class Derived : public Base {  
public:  
    void func() override { // 使用 override 关键字  
        std::cout << "Derived::func()" << std::endl;  
    }  
};  
  
int main() {  
    Derived d;  
    d.func(); // 输出 "Derived::func()"  
    return 0;  
}
```

 **注意事项**
  * 即使不使用 override 关键字，只要函数签名匹配，也可以重写基类的虚函数。但是，使用 override 可以提供更好的安全性和可读性。
  * 如果基类中的虚函数被声明为 final，那么它不能在派生类中被重写。在这种情况下，尝试使用 override 关键字会导致编译错误。
  * 只能用于非静态成员函数，且必须是类的成员函数（不能是友元函数）。



### volatile 
 * volatile告诉编译器，某个特定的变量可能在程序的外部被改变，因此编译器不应将其视为优化的一部分。
   * 在大多数情况下，编译器会尝试优化代码以提高性能，例如，它会假设变量在两次读取之间不会被其他线程或硬件事件修改。
   * 然而，在某些特殊情况下，例如访问硬件寄存器、多线程编程中的共享变量，或者与某些信号处理函数交互时，这种假设可能不成立。
   * 在这些情况下，使用volatile可以确保编译器不会做出这些假设，并且每次使用变量时都会从内存中读取其值。

 **定义**
  * 阻止编译器优化：编译器可能会进行某些优化，比如将变量的值存储在寄存器中，而不是每次都从内存中读取。如果变量被声明为 volatile，那么编译器就不会进行这样的优化，每次使用这个变量时都会直接从内存中读取。
  * 硬件寄存器访问：在嵌入式系统或操作系统内核中，经常需要直接访问硬件寄存器。由于这些寄存器的值可能随时由硬件改变，因此应该使用 volatile 来确保每次访问都是直接从硬件读取的。
  * 多线程编程：在多线程编程中，一个线程可能修改了一个全局变量的值，而另一个线程正在读取这个变量的值。如果这个变量没有被声明为 volatile，那么编译器可能会缓存这个变量的值，导致第二个线程读取到的是旧值。使用 volatile 可以防止这种情况。

```c++

// 基本类型变量：每次使用a时，编译器都会直接从内存中读取其值，而不是从寄存器或缓存中读取。
volatile int a = 0;

// 指针：它们指向的变量的值可能随时被改变，因此编译器不会对其进行优化。
volatile int *p = &a;
int *volatile q = &b;
volatile int *volatile r = &c;

// 多线程：
volatile bool flag = false;  
  
void thread1() {  
    while (!flag) {  
        // do something  
    }  
    // do something else  
}  
  
void thread2() {  
    // do some work  
    flag = true;  
}

// 硬件寄存器访问：直接读取或修改硬件寄存器的值，编译器不会对这些操作进行优化，确保了直接和硬件的交互。
#define HARDWARE_REGISTER_ADDRESS 0x12345678  
volatile uint32_t* hardware_register = (volatile uint32_t*) HARDWARE_REGISTER_ADDRESS;
  
// 读取寄存器值  
uint32_t value = *hardware_register;
  
// 修改寄存器值  
*hardware_register = new_value;
```

### enum

  ```c++
  enum class B: unsigned char /** 每个枚举都是unsigned char类型的 */
  {
      my_enum3 = 0,
  }
  ```
 **特点**
  * 与整型之间不会发生隐式类型转换，除非用static_cast强制转换
  * 可以指定底层的数据类型，默认是int
  * 需要通过域运算符来访问枚举成员


### extern定义
 * extern：说明是在别处定义的，在此处引用，相对于#include方法，加速编译过程
   * 用于支持c或c++函数调用规范，当在c++程序中调用c的库，需要extern c的声明引用，主要因为c++和c编译完成后，目标代码的命名规则不同，用来解决名字匹配


### #define -> typedef

 **不同**
  * 编译器处理
    * typedef在编译阶段，有类型检查的功能
    * define则是宏定义，发生在预处理阶段
  * 作用域的限制
    * define没有作用域的限制
    * typedef有自己的作用域
  * 指针操作不同
    * typedef int * pint; const pint p1 = &i1;  指针常量
    * #define PINT int * const PINT p2 = &i2; 常量指针




### this指针处理

 **作用**
  * 指向非静态成员函数所作用的对象

 **什么时候创建**
  * 调用非静态函数时才会使用的

 **delete this**
  * 为将被释放的内存调用一个或多个析构函数（因此不能在析构中调用delete this），类对象的内存空间被释放，之后不能涉及this指针，如操作数据成员，调用虚函数等

## const

### const与变量

 **特点**
  * 限定不可更改


### const与指针

 **特点**
  * `int const * a`与`int * const a`


 **指向常量的指针**
  * `const int * a`
  * `int const * a`


 **指针常量**
  * `int * const a`


### const与函数
  * `const int& func(int& a)`：修饰返回值为const
  * `int& func(const int& a)`：修饰形参
  * `int& func(int& a) const{}`：const成员函数
    * 不允许修改类的成员的值


### const与类
  **const修饰类成员变量**
   * 在对象的声明周期内是常量，对整个类而言是可以改变的。
   * 不能在类内初始化const成员变量，在初始化列表中初始化。


  **const类对象成员函数**
   * 不允许修改类的成员的值


  **const对象**
   * 只能调用const函数



### const -> #define
 **不同**
  * 类型
    * 宏定义是字符替换，没有数据类型的区别
    * const常量是常量的声明，有类型区别
  * 安全检查
    * 可能产生边际效应等错误
    * 在编译阶段进行类型检查
  * 编译器处理
    * 宏定义是一个"编译时"概念
    * const常量是一个"运行时"概念
  * 存储方式
    * 宏定义：代码段
    * const常量：data区
  * 是否可以做函数参数
    * 可以在函数的参数列表中出现




### =default 和=delete

用于显式指定和禁止某些行为
```c++
struct classA {
 classA() = default; // 声明⼀个⾃动⽣成的函数
 classA(T value);
 void *operator new(size_t) = delete; // 禁⽌⽣成new运算符
};
```

### 泛化常数 constexpr

```c++
// 告诉编译器这是编译期常量
constexpr int N = 5;
int arr[N];

// 也可以为常量表达式
constexpr int getFive(){ return 5; }
int arr[getFive() + 1];
```


### decltype

  * 返回：用于在编译时检查实体的类型，并返回该实体的类型。
  * 模板元编程：decltype 提供了一种在模板元编程和类型推导中非常有用的机制，因为它可以自动推断出表达式的类型，而无需显式地指定。
 
 **应用**
  * 多出现在泛型编程，编译期间确定

 **decltype(c)**
  * 若 e 为⼀个⽆括号的变量、函数参数、类成员，则返回类型为该变量/参数/类成员在源程序中的声明类型
  * 否则的话，根据表达式的值分类
    * 若 e 是⼀个左值，即可寻址的，返回 T& ；
    * 若 e 是⼀个临终值，则返回值为 T&& ；
    * 若 e 是⼀个纯右值，则返回值为 T 。

```c++
const std::vector<int> v(1);
const int&& foo(); // 返回临终值：⽣命周期已结束但内存还未拿⾛
auto a = v[0]; // a 为 int
decltype(v[0]) b = 0; // b 为 const int&
 // 即 vector<int>::operator[](size_type) const 的
返回值类型
auto c = 0; // c, d 均为 int
auto d = c; 
decltype(c) e; // e 为 int，即 c 的类型
decltype((c)) f = e; // f 为 int&，因为 c 是左值
decltype(0) g; // g 为 int，因为 0 是右值
```

### 结构体
 为内存对齐后的结果
 成员对齐、整体对齐
 **定义**
  * **不同类型**的数据组成整体


 **特点**
  * 每个成员都有自己的独立地址
  * **sizeof**之后是内存对齐之后所有成员的长度和


 **struct与数组**
  * 原因：数组空间有限，有些数组需要动态分配空间，编译期间初始化无法得到数组的长度
    * 在结构体和类中定义空数组，其数组内容不占用struct空间，可以在最后分配malloc中直接分配动态buffer，`malloc(sizeof(struct()+buff.size()))`
  * 特点
    * 不定长数组只能作为结构体的最后一个成员出现，只能有一个不定长数组。
    * 不定长数组不能被初始化，只能在运行时动态分配和释放内存空间。


### 共同体
 **定义**
  * 各成员共享一段内存空间，大小为成员中最长成员的长度


 **特点**
  * 共享内存可以将变量付给任一成员，但每次只能赋一种值，会覆盖



### 字节对齐
 **引入原因**
  * CPU访问数据效率问题，对于0-7存储的变量读取只需要一次，否则需要两次


 **对齐规则**
  * x86 -> GCC默认4字节对齐
    * 可以使用`__attribute__`选项改变对齐规则
  * vs中使用`#pragma pack (n)`改变


 **常见变量字节数**
  
  | type | bytes |
  | ----- | ----- |
  | char | 1 |
  | short | 2 |
  | int | 4 |
  | double | 8 |
  | int b[0] | 0 |


 **struct对齐**
  * 对char、char、int类型有8个bytes
  * 对char[5]、short、int类型有12个bytes
  * 对char、double、char类型有24个bytes
  * 数组`int[]`或`int[0]`指向前一个位置，本身不占空间
    * char、int、int[]有8个bytes
    * int[]占用4个bytes
    * 空结构体占用1 bytes



