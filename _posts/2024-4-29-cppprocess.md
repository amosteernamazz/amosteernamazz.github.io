---
layout: article
title: C++ 流程
key: 100008
tags: C++ 流程
category: blog
date: 2019-09-07 00:00:00 +08:00
mermaid: true
---



## 预处理，编译，汇编，链接程序的区别

 * 步骤：预处理器→编译器→汇编器→链接器
 * 预处理阶段：写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 #开头的命令，修改原始的程序，如#include<stdio.h> 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件。
 * 编译阶段：编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是汇编语⾔程序。⾼级语言是源程序。所以注意概念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼级语⾔翻译的汇编语⾔相同。
 * 汇编阶段：汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即.o⽂件。hello.o是⼀个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。
 * 链接阶段：⽐如 hello 程序调⽤printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得到的是可执⾏⽬标⽂件。

## 动态链接和静态链接

 * 静态连接库就是把 (lib) ⽂件中⽤到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件。动态链接就是把调⽤的函数所在⽂件模块（DLL）和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候再从 DLL 中寻找相应函数代码，因此需要相应DLL ⽂件的⽀持。
 * 静态链接库与动态链接库都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib中的指令都全部被直接包含在最终生成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时可以“动态”地引⽤和卸载这个与 EXE 独立的 DLL ⽂件。
 * 静态链接库和动态链接库的另外⼀个区别在于静态链接库中不能再包含其他的动态链接库或者
 静态库，⽽在动态链接库中还可以再包含其他的动态或静态链接库。
 * 动态库就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执行。如果在当前工程中有多处对dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷贝。但如果有多处对 lib ⽂件中同⼀个函数的调用，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷贝。


## 阶段

 * 预编译
   * #define、#if、#ifdef、#ifndef、#undef、#endif、#else
 * 编译期
   * enum、struct、union、auto、decltype、friend、声明、全局static、constexpr、inline、全局变量、vtable
   * 第二步：编译期创建的对象
     * 需要使用动态初始化
     * 执行顺序：基类局部static -> 子类局部static -> 非静态代码 -> 派生类的基类构造(执行基类普通成员的初始化，按照基类对象声明顺序执行) -> 派生类的成员构造(按照成员声明顺序) -> 派生类构造(派生类普通成员初始化)（包括vptr）
   * 编译期析构
     * 执行顺序：派生类析构 -> 派生类成员类对象析构 -> 基类析构
 * 运行期
   * 运行期创建的对象
     * 执行顺序：基类局部static -> 子类局部static -> 非静态代码 -> 派生类的基类构造(执行基类普通成员的初始化，按照基类对象声明顺序执行) -> 派生类的成员构造(按照成员声明顺序) -> 派生类构造(派生类普通成员初始化)（包括vptr）
   * 运行期析构
     * 执行顺序：派生类析构 -> 派生类成员类对象析构 -> 基类析构
   * 运行期virtual

## 静态绑定和动态绑定

 静态绑定：发生在编译期间，程序声明时所采用的类型
  * 非虚函数、缺省参数值。重定义，重载
 动态绑定：发生在运行期间，目前所指对象的实际类型
  * virtual

<!--more-->


## 动态联编和静态联编

 * 指计算机程序不同部分彼此关联，分为静态和动态
 * 静态联编是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差
 * 动态联编指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果
 * C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类的指针变量名->虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）

 **实现的条件**
  * 必须把动态联编的⾏为定义为类的虚函数；
  * 类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；
  * 必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数；


## 对象构建顺序

  1. 先执行base的static，再执行派生类static（按出现顺序）
  2. 非静态代码（成员方法，成员变量，成员代码块等）如果有类对象则按照顺序构建
  3. 构造函数
     1. 基类普通成员初始化、基类构造（按照基类在派生类中出现的顺序，而不是成员初始化顺序），如果对象有vptr，vptr不断被重定义
     2. 成员类对象构造函数（如果有多个成员类构造函数，调用顺序是对象在类中被声明的顺序）
     3. 派生类普通成员初始化、派生类构造

## 析构顺序

  1. 派生类析构
  2. 成员类对象析构
  3. 基类析构


## 何时需要初始化

 * 引用成员变量
 * const
 * 基类构造有一组参数
 * 成员构造有一组参数
 * 初始化顺序：按照成员声明顺序决定



## C++初始化

 **类型**
  * 编译初始化
  * 动态初始化

### 编译初始化

 * 静态初始化在程序加载的过程中完成
 * 包括全局变量初始化和constexpr类型的初始化
   * zero initialization 的变量会被保存在 bss 段
   * constexpr initialization 的变量则放在 data 段内
   * 其次全局类对象也是在编译器初始化。

### 动态初始化
 出现时机：出现在编译期和运行期的局部位置初始化
 * 动态初始化也叫运行时初始化
 * 需要经过函数调用才能完成的初始化、类初始化
   * 局部静态类对象的初始化
   * 局部静态变量的初始化
 * 动态初始化一般出现在

## 动态初始化中静态局部变量2个问题

### 线程安全问题

 **实现方法**
  * 一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起而不是跳过
    * 局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中。
    * 然后编译器会生成一个保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。
      * 它的最低的一个字节被用作相应静态变量是否已被初始化的标志
        * 若为 0 表示还未被初始化，否则表示已被初始化(if ((guard_for_bar & 0xff) == 0)判断)。 
      * __cxa_guard_acquire 实际上是一个加锁的过程，
        *  相应的 __cxa_guard_abort 和__cxa_guard_release 释放锁。

### 内存泄漏问题

 **原因**
  * 在局部作用域消失时，data区仍然保存其内存空间
  * 执行路径不明
    * 对于局部静态变量，构造和析构都取决于程序的执行顺序。程序的实际执行路径不可预知的
  * 关系不明
    * 局部静态变量分布在程序代码各处，彼此直接没有明显的关联，很容易让开发者忽略它们之间的这种关系

 **建议**
  * 减少使用局部静态变量



