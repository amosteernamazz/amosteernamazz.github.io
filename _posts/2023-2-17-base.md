---
layout: article
title: 交易系统
key: 100001
tags: C++ 交易系统
category: blog
date: 2023-02-17 00:00:00 +08:00
mermaid: true
---

# 交易系统基础库开发

## 文件系统

 文件系统采用boost进行封装
 文件系统包括文件夹创建、文件创建、判断是否有效、得到文件大小、进入文件头部尾部、文件指针、写、读、删除

### boostfile.hpp

<!--more-->

  ```c++
  #include<string>
  #ifdef _WIN32
  #define WIN32_LEAN_AND_MEAN
  #include <windows.h>
  #else
  #include <unistd.h>
  #endif

  class BoostFile{
  private:
    boost::interprocess::file_handle_t _handle;

  public:
    BoostFile()
    {
      _handle=boost::interprocess::ipcdetail::invalid_file(); 
    }
    ~BoostFile()
    {
      close_file();
    }

  public:
    static bool delete_file(const char *name)
    {
      return boost::interprocess::ipcdetail::delete_file(name);
    }

    static bool read_file_contents(const char *filename,std::string &buffer)
    {
      BoostFile bf;
      if(!bf.open_existing_file(filename,boost::interprocess::read_only))
        return false;
      unsigned int filesize=(unsigned int)bf.get_file_size();
      if(filesize==0)
        return false;
      buffer.resize(filesize);
      return bf.read_file((void *)buffer.c_str(),filesize);
    }


      bool read_file(void *data, std::size_t numdata)
    {
      unsigned long readbytes = 0;
    #ifdef _WIN32
      int ret = ReadFile(_handle, data, (DWORD)numdata, &readbytes, NULL);
    #else
      readbytes = read(_handle, data, (std::size_t)numdata);
    #endif
      return numdata == readbytes;
    }

  }
  ```

### BoostMappingFile.hpp
 完成大文件的导入
 其中使用`boost::interprocess::file_mapping`和`boost::interprocess::mapped_region`

 * file_mapping:对象对应一个文件,这个对象写入的数据将自动保存关联的物理文件上
 * mapped_region:将任意部分映射到地址空间

  ```c++
    bool map(const char *filename,
      int mode=boost::interprocess::read_write,
      int mapmode=boost::interprocess::read_write,bool zeroother=true)
    {
      if (!boost::filesystem::exists(filename))
      {
        return false;
      }
      _file_name = filename;

      _file_map = new boost::interprocess::file_mapping(filename,(boost::interprocess::mode_t)mode);
      if(_file_map==NULL)
        return false;

      _map_region = new boost::interprocess::mapped_region(*_file_map,(boost::interprocess::mode_t)mapmode);
      if(_map_region==NULL)
      {
        delete _file_map;
        return false;
      }

      return true;
    }
  ```


## CPU 线程相关

### CPU core

  ```c++
  static uint32_t get_cpu_cores(){
    static uint32_t cores = std::thread::hardware_concurrency();
    return cores;
  }
  ```

### 线程绑定

  ```c++
  #ifdef _WIN32
  #include <thread>
    static bool bind_core(uint32_t i){
      uint32_t cores = get_cpu_cores();
      if(i >=cores){
        return false;
      }
      // 得到当前运行的线程句柄
      HANDLE hThread = GetCurrentThread();
      // 将线程绑定到第i个CPU上
      DWORD_PTR mask = SetThreadAffinityMask(hThread, (DWORD_PTR) (1<< i));
      return (mask!=0);
    }
  #else
    static bool bind_core(uint32_t i){
    }

  #endif
  ```

## 精度相关

### 精度定义

  ```c++
  #pragma once
  #include <math.h>

  namespace decimal{
    const double EPSINON = 1e-6;
    
    inline double rnd(double v, int exp = 1){
      return round (v*exp) / exp;
    }

    inline bool eq(double a, double b = 0.0){
      return (fabs(a - b) <EPSINON);
    }

    
    inline bool gt(double a, double b = 0.0)
    {
      return a - b > EPSINON;
    }

    inline bool lt(double a, double b = 0.0)
    {
      return b - a > EPSINON;
    }

    inline bool ge(double a, double b = 0.0)
    {
      return gt(a, b) || eq(a, b);
    }

    inline bool le(double a, double b = 0.0)
    {
      return lt(a, b) || eq(a, b);
    }

    inline double mod(double a, double b)
    {
      return a / b - round(a / b);
    }
  }
  ```

## 动态库辅助

 将跨平台的差异封装，方便调用

### 





## 常见类型转换

### UTF8toChar

### ChartoUTF8

### URLEncode

### URLDecode

## 交易系统定义

### 期货定义

  主力合约后缀、次主力合约后缀、前复权合约代码后缀

  不复权

  ![](https://xqimg.imedao.com/165f13e3b8c24313fe3059f4.png!800.jpg)

  前复权

  前复权就是以目前股价为基准，保持现有价位不变，缩减以前价格，把除权前的K线向下平移，使图形吻合，保持股价走势的连续性。简单说就是把除权前的价格按现在的价格换算过来，复权后现在价格不变，以前的价格减少

  ![](https://xqimg.imedao.com/165f13f3d5b23b83fe1ef5fb.png!800.jpg)

  后复权

  后复权是指在K线图上以除权前的价格为基准来测算除权后股票的市场成本价。简单说就是把除权后的价格按以前的价格换算过来，复权后以前的价格不变，现在的价格增加。通过后复权我们可以看出该股上市以来累计涨幅，如果当时买入，参与全部配送、分红，一直持有到目前的价位


  ![](https://xqimg.imedao.com/165f1409e7e51a43fd93397a.png!800.jpg)

  ```c++
  //主力合约后缀
  static const char* SUFFIX_HOT = ".HOT";

  //次主力合约后缀
  static const char* SUFFIX_2ND = ".2ND";

  //前复权合约代码后缀
  static const char SUFFIX_QFQ = '-';

  //后复权合约代码后缀
  static const char SUFFIX_HFQ = '+';
  ```
### 期货类定义
 ![](http://www.khqihuo.com/uploads/allimg/210422/17-210422111400S1.png)

  ```c++
  class CodeHelper{
    public typedef struct _CodeInfo{
      char _code[MAX_INSTRUMENT_LENGTH];		//合约代码
      char _exchg[MAX_INSTRUMENT_LENGTH];		//交易所代码
      char _product[MAX_INSTRUMENT_LENGTH];	//品种代码
      char _ruletag[MAX_INSTRUMENT_LENGTH];	//
      char _fullpid[MAX_INSTRUMENT_LENGTH];	// 由交易所代码和品种代码确定

      uint8_t	_exright;	//是否是复权代码,如SH600000Q: 0-不复权, 1-前复权, 2-后复权

      //是否是复权代码
      inline bool isExright() const { return _exright != 0; }

      //是否前复权代码
      inline bool isForwardAdj() const { return _exright == 1; }

      //是否后复权代码
      inline bool isBackwardAdj() const { return _exright == 2; }

      //标准品种ID
      inline const char* stdCommID()
      {
        if (strlen(_fullpid) == 0)
          fmtutil::format_to(_fullpid, "{}.{}", _exchg, _product);

        return _fullpid;
      }
      
      _CodeInfo()
      {
        memset(this, 0, sizeof(_CodeInfo));
        //_category = CC_Future;
      }

      inline void clear()
      {
        memset(this, 0, sizeof(_CodeInfo));
      }
      inline bool hasRule() const
      {
        return strlen(_ruletag) > 0;
      }
    }CodeInfo;


  }
  ```

### 期货类常用方法

**期货期权合约代码**

 判断是否是期货期权合约代码、是否是标准分月期货合约代码、标准代码转标准品种ID
 CFFEX.IO2302-C-3350
  * CFFEX:中国金融期货交易所
  * IO:期权交易
  * 2302:到期年份和到期月份
  * C:期权类型
    * C：认购期权
    * P：认沽期权
  * 3350:行权价格，其中后三位为小数位，除权除息日起修改为调整后行权价格，不超过6位

  ```c++
  // CFFEX.IO2302-C-3350
  static bool	isStdChnFutOptCode(const char* code)
    {
      /* 定义正则表达式 */
      //static cregex reg_stk = cregex::compile("^[A-Z]+.[A-z]+\\d{4}.(C|P).\\d+$");	//CFFEX.IO2007.C.4000
      //return 	regex_match(code, reg_stk);
      char state = 0;
      std::size_t i = 0;
      for(; ; i++)
      {
        char ch = code[i];
        if(ch == '\0')
          break;

        if(state == 0)
        // 判断所在国家
        {
          if (!('A' <= ch && ch <= 'Z'))
            return false;

          state += 1;
        }
        else if (state == 1)
        {
          // 国家代码仍然有
          if ('A' <= ch && ch <= 'Z')
            continue;

          if (ch == '.')
            state += 1;
          else
            return false;
        }
        else if (state == 2)
        {
          // 判断是否是期权或期货代码
          if (!('A' <= ch && ch <= 'z'))
            return false;

          state += 1;
        }
        else if (state == 3)
        {
          // 判断是否是期权或期货代码
          if ('A' <= ch && ch <= 'z')
            continue;

          // 判断在时间选择内，时间始终都为4位
          if ('0' <= ch && ch <= '9')
            state += 1;
          else
            return false;
        }
        else if (state >= 4 && state <= 6)
        {
          // 时间始终都为4位
          if ('0' <= ch && ch <= '9')
            state += 1;
          else
            return false;
        }
        // 下一个选择
        else if (state == 7)
        {
          if (ch == '.')
            state += 1;
          else
            return false;
        }
        else if (state == 8)
        {
          // 类型选择
          if (ch == 'C' || ch == 'P')
            state += 1;
          else
            return false;
        }
        else if (state == 9)
        {
          if (ch == '.')
            state += 1;
          else
            return false;
        }
        else if (state == 10)
        {
          // 最后合约价格
          if ('0' <= ch && ch <= '9')
            state += 1;
          else
            return false;
        }
        else if (state == 11)
        {
          if ('0' <= ch && ch <= '9')
            continue;
          else
            return false;
        }
      }

      return (state == 11);
    }
  ```

**标准分月期货合约代码**

CFFEX.IF.2007
  ```c++
   //CFFEX.IF.2007
    static inline bool	isStdMonthlyFutCode(const char* code)
    {
      using namespace boost::xpressive;
      /* 定义正则表达式 */
      static cregex reg_stk = cregex::compile("^[A-Z]+.[A-z]+.\\d{4}$");	//CFFEX.IO.2007
      return 	regex_match(code, reg_stk);
    }

  ```

**标准代码转标准品种ID**

SHFE.ag.1912 -> SHFE.ag
SSE.600000 -> SSE.600000
  ```c++
    static inline std::string stdCodeToStdCommID(const char* stdCode)
    {
      auto idx = find(stdCode, '.', true);
      auto idx2 = find(stdCode, '.', false);
      if(idx != idx2)
      {
        //前后两个.不是同一个，说明是三段的代码
        //提取前两段作为品种代码
        return std::string (stdCode, idx);
      }
      else
      {
        //两段的代码，直接返回
        //主要针对某些交易所，每个合约的交易规则都不同的情况
        //这种情况，就把合约直接当成品种来用
        return stdCode;
      }
    }
  ```


**基础分月合约代码提取基础品种代码**

 
 ag1912 -> ag
 **永续合约无法转变**

  ```c++
    static inline std::string rawMonthCodeToRawCommID(const char* code)
    {
      int nLen = 0;
      while ('A' <= code[nLen] && code[nLen] <= 'z')
        nLen++;

      return std::string(code, nLen);
    }
  ```


### 
