---
layout: article
title: C++运行时特征
key: 100002
tags: C++ 多态
category: blog
date: 2023-02-07 00:00:00 +08:00
mermaid: true
---


# **c++运行时特征**


## 阶段

 * 预编译
   * #define、#if、#ifdef、#ifndef、#undef、#endif、#else
 * 编译期
   * enum、struct、union、auto、decltype、friend、声明、全局static、constexpr、inline、全局变量、vtable
   * 第二步：编译期创建的对象
     * 需要使用动态初始化
     * 执行顺序：基类局部static -> 子类局部static -> 非静态代码 -> 派生类的基类构造(执行基类普通成员的初始化，按照基类对象声明顺序执行) -> 派生类的成员构造(按照成员声明顺序) -> 派生类构造(派生类普通成员初始化)（包括vptr）
   * 编译期析构
     * 执行顺序：派生类析构 -> 派生类成员类对象析构 -> 基类析构
 * 运行期
   * 运行期创建的对象
     * 执行顺序：基类局部static -> 子类局部static -> 非静态代码 -> 派生类的基类构造(执行基类普通成员的初始化，按照基类对象声明顺序执行) -> 派生类的成员构造(按照成员声明顺序) -> 派生类构造(派生类普通成员初始化)（包括vptr）
   * 运行期析构
     * 执行顺序：派生类析构 -> 派生类成员类对象析构 -> 基类析构
   * 运行期virtual

<!--more-->

## C++初始化

 **类型**
  * 编译初始化
  * 动态初始化

### 编译初始化

 * 静态初始化在程序加载的过程中完成
 * 包括全局变量初始化和constexpr类型的初始化
   * zero initialization 的变量会被保存在 bss 段
   * constexpr initialization 的变量则放在 data 段内
   * 其次全局类对象也是在编译器初始化。

### 动态初始化
 出现时机：出现在编译期和运行期的局部位置初始化
 * 动态初始化也叫运行时初始化
 * 需要经过函数调用才能完成的初始化、类初始化
   * 局部静态类对象的初始化
   * 局部静态变量的初始化
 * 动态初始化一般出现在

## 动态初始化中静态局部变量2个问题

### 线程安全问题

 **实现方法**
  * 一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起而不是跳过
    * 局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中。
    * 然后编译器会生成一个保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。
      * 它的最低的一个字节被用作相应静态变量是否已被初始化的标志
        * 若为 0 表示还未被初始化，否则表示已被初始化(if ((guard_for_bar & 0xff) == 0)判断)。 
      * __cxa_guard_acquire 实际上是一个加锁的过程，
        *  相应的 __cxa_guard_abort 和__cxa_guard_release 释放锁。

### 内存泄漏问题

 **原因**
  * 在局部作用域消失时，data区仍然保存其内存空间
  * 执行路径不明
    * 对于局部静态变量，构造和析构都取决于程序的执行顺序。程序的实际执行路径不可预知的
  * 关系不明
    * 局部静态变量分布在程序代码各处，彼此直接没有明显的关联，很容易让开发者忽略它们之间的这种关系

 **建议**
  * 减少使用局部静态变量



## 对象构建顺序

  1. 先执行base的static，再执行派生类static（按出现顺序）
  2. 非静态代码（成员方法，成员变量，成员代码块等）如果有类对象则按照顺序构建
  3. 构造函数
     1. 基类普通成员初始化、基类构造（按照基类在派生类中出现的顺序，而不是成员初始化顺序）
     2. 成员类对象构造函数（如果有多个成员类构造函数，调用顺序是对象在类中被声明的顺序）
     3. 派生类普通成员初始化、派生类构造

## 析构顺序

  1. 派生类析构
  2. 成员类对象析构
  3. 基类析构








## 构造函数


### 构造类型

 **默认构造**
  * 无参构造


 **一般构造**
  * 包含各种参数，参数顺序个数不同可以有不同构造


 **拷贝构造**
  * 函数参数必须为引用
    * 如果是值传递，则会递归调用拷贝构造
    * 如果是指针类型，则为值传递
  * 浅拷贝，存在问题，进行重写


 **移动构造**
  * 避免分配新空间，将原来的对象直接拿过来使用


 **赋值构造**
  * 
 **类型转换构造**
  * 
 


### 构造中的问题
 
 **构造中的内存泄漏问题**
  * 原因：c++只会析构已经完成的对象。
  * 出现：如果构造函数中发生异常，不会调用析构函数。如果在构造函数中申请了内存操作，则会造成内存泄漏。
  * 派生类有问题：如果有继承关系，派生类中的构造函数抛出异常，那么基类的构造函数和析构函数可以照常执行的。
  * 解决办法：用智能指针来管理内存

### 拷贝构造中的浅拷贝和深拷贝

 **使用深拷贝的场景**
 * 在copy构造中，copy的对象是否存在指针，如果有需要重写copy构造，因为浅拷贝不会存储数据，相同指针指向同一对象，**当数据成员中有指针时，必须要用深拷贝。**

 **系统默认**

  系统默认的拷贝函数——即浅拷贝。当数据成员中没有指针时，浅拷贝是可行的；

 **原因**
  如果没有自定义拷贝构造函数，会调用默认拷贝构造函数，这样就会调用两次析构函数。**第一次析构函数delete了内存，第二次的就指针悬挂了。**所以，此时，必须采用深拷贝。

 **操作**
  * 深拷贝在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。
  简而言之，**当数据成员中有指针时，必须要用深拷贝**。

## 析构函数
 **析构中的问题**
  * 析构函数不能、也不应该抛出异常
    * 析构函数抛出异常，则异常点之后的程序不会执行，造成资源泄露
    * 异常发生时，异的传播过程中会进行栈展开。调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。
      * 解决办法：把异常完全封装在析构函数内部，决不让异常抛出函数之外


## 实例化
 **不可实例化的类**
  * 抽象类（本身是抽象）
  * 工具类（直接通过static调用函数）

 **如何阻止实例化**
  * 包含纯虚函数
  * 构造函数私有

### 实例化中的变量初始化时机与顺序

 **时机**
 * 类中const初始化必须在构造函数初始化列表中初始化
 * 类中static初始化必须在类外初始化
 * 成员变量初始化顺序按照类中声明顺序，而构造函数初始化顺序按照成员变量在构造函数中位置决定

 **顺序**
 * 初始化base类中的static部分（按程序出现顺序初始化）
 * 初始化派生类中的static部分（按程序出现顺序初始化）
 * 初始化base类的普通成员变量和代码块，再执行父类的构造方法；
 * 初始化派生的普通成员变量和代码块，在执行子类的构造方法；




## 运行期virtual
![](https://img-blog.csdnimg.cn/20201005162842163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc2lnag==,size_16,color_FFFFFF,t_70#pic_center)

 **原理**
  * 对象中有**虚函数的指向的指向**（编译期间**创建对象**或运行时创建对象时创建）和虚函数表（每个**类的虚函数入口地址**，为**编译期**创建）

  * 管理对象的空间中有vptr地址（随对象创建而创建），vptr指针对应的vtable（在编译期确定，是针对类的）中保存该对象的虚函数成员，其保存函数的入口地址


 **多继承**
  * 在多继承中，vtable会有多个vptr地址，对应不同基函数的vptr


 **运行时virtual**
  * 为了多态，编译器会给每个包含虚函数或继承了虚函数的类自动建立一个虚函数表，当子类继承父类的虚函数时，子类会有自己的vtable
    * 如果存在**大量的子类继承**，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费


 **多态的实现原理（为什么构造和析构需要按顺序）**

  [虚表的写入时机、多态的实现原理、构造析构顺序的原因](https://blog.csdn.net/weixin_43919932/article/details/104356460)

 ![](https://img-blog.csdnimg.cn/20200217142930458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxOTkzMg==,size_16,color_FFFFFF,t_70)



 **构造函数与virtual**

  构造函数是否可以为virtual
  * 不能
  * 虚函数调用需要对象构建得到虚表调用，而对象还没有构造。

  构造函数中调用virtual
  * 破坏C++动态联编
    * 父类对象构造中在子类之前，子类的成员还没有初始化


 **析构函数与virtual**
 
  析构函数的子类应该声明为virtual
  * 为了确保析构的时候，释放派生类对象，需要基类析构函数声明为虚函数，否则只会析构对应的父类对象，而不会析构子类对象。


 **哪些函数不能是虚函数**
  * 构造函数
  * 某些析构函数
  * 友元函数（原因不是类成员）
  * 静态成员函数（原因：不属于任何对象或实例）
  * 内联函数（原因：需要在编译期间展开，同时需要类对象有vptr，但没有地址）
  * 成员函数模板（原因：成员模板函数需要在调用的时候才能确定，而虚函数需要解析时候确定vtable大小）


## 纯虚函数
 **区别**
  * 纯虚函数用于如果生成基类对象则不合理的场景
  * 其使得纯虚函数的类为抽象基类，本身成为了接口


 **使用**
  `virtual void exit()=0`=0表示为纯虚函数

## 堆上和栈上的对象

 **区别**
  * 声明周期
    * 需要生命周期比上下文长的生命周期，则只能在堆上创建
      * 只要能在栈上创建对象，就在栈上创建；否则的话，如果你不得不需要更长的生命周期，只能选择堆上创建
    * 某些情况如果是在栈上创建，但数据仍然在堆上`std::vector v`对象v创建在栈，但其数据在栈上
  * 性能
    * 栈性能更快，栈有专门的寄存器，压栈出栈指令效率更高，堆是由OS动态调度，堆内存可能被OS调度在非物理内存中，或是申请内存不连续，造成碎片过多等问题；
    * 堆都是动态分配的，栈是编译器完成的。栈的分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现

### 只在堆上生成对象的类
  ```c++
  class A {
    // A a; 创建对象是利用编译器确定，需要public的构造和析构，因此使用private或protected构造和析构可以取消静态创建，但针对需要继承的类型有进一步限制为protected
  protected:
    A(){}
    ~A(){}
  public:
    static A* create(){
      return new A();
    }
    // 在析构中因为无法调用，使用单独的delete()函数
    void delete(){
      delete this;
    }

  };
  ```

### 只在栈上生成对象的类
  ```c++
  class A{
  private:
    void operator delete(void* ptr){}
    void * operator new (size_t t){}
  public:
    A(){}
    ~A(){}
  };
  ```


## C++内存布局


### 栈
 **特点**
  * 向下生长
  * 保存函数的局部变量，参数以及返回值


### 堆
 **特点**
  * 向上生长
  * 用户分配的动态内存区域，存在内存泄漏问题，需要及时释放内存，否则需要等程序退出


### bss区
 **特点**
  <!-- * global 初始化在此区，初始化后的非0放在data
  * 未初始化的static全局/局部变量 -->
  * 编译时：对程序全局变量载入时，由内核置为0
  * 运行时：未初始化的static全局/局部变量


### data区
 **特点**
  <!-- * const初始化在此区
  * 初始化后非0的global、初始化后的static全局/局部变量 -->
  * 初始化后的全局变量
  * 初始化后的static全局/局部变量
  * 编译时：const初始化后的const


### text段
 **特点**
  * 只读，一般为二进制文件



