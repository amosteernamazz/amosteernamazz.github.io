---
layout: article
title: C++ 流程
key: 100006
tags: C++ 流程
category: blog
date: 2019-09-07 00:00:00 +08:00
mermaid: true
---



## C++代码的编译流程

 * 步骤：预处理器→编译器→汇编器→链接器
 * 预处理阶段：在这个阶段，编译器会处理预处理指令（以 '#' 开头），如 #include、#define 等。预处理器会将这些指令替换为相应的内容，生成一个被称为 "translation unit" 的中间文件。
 * 编译阶段：在这个阶段，预处理后的代码会被编译成汇编语言。编译器会将源代码转换成汇编语言的表示形式，这个过程包括了语法和语义分析，以及生成中间表示（如抽象语法树）编译器可能会进行一系列的优化操作，以提高程序的性能和效率。这些优化包括但不限于循环展开、内联函数、常量折叠等。该阶段会构建继承关系。编译工具包括GCC、Clang、MSVC等
 * 汇编阶段：汇编器将汇编代码转换为机器代码，也称为目标代码或对象代码。
目标代码是特定于体系结构的，这意味着为x86架构生成的代码不能直接在ARM架构上运行。
 * 链接阶段：如果程序由多个源文件组成，那么编译后会生成多个目标文件（Object Files）。链接器将这些目标文件以及所需的库文件链接在一起，生成最终的可执行文件。这个过程包括解析符号引用、地址重定向和符号重定向等步骤。链接器可以生成两种类型的输出：可执行文件（可以直接运行）和库文件（包含可以在其他程序中使用的代码和数据）。


## 静态链接和动态链接

### 静态链接
 
 .a
 **定义**

  * 静态链接是将程序的所有模块在编译时链接到一个单独的可执行文件中的过程。
  * 在静态链接中，目标文件中的所有模块和库都会被复制到最终的可执行文件中，使得可执行文件独立于系统环境。

 **过程**
  * 在编译和链接程序时，链接器将目标文件中的所有符号（如函数和变量）解析并合并到一个单独的可执行文件中。
  * 静态链接器将所有依赖项（如库文件）的代码和数据都复制到可执行文件中，因此生成的可执行文件比较大。

 **优点**

  * 独立性：生成的可执行文件可以在没有外部依赖的情况下在任何环境中运行。
  * 性能：静态链接可以避免运行时的库加载和解析过程，因此可以提高程序的启动速度。

 **缺点**
  * 可执行文件较大：每个可执行文件都包含了所有依赖项的代码和数据，因此可能会占用较多的磁盘空间。
  * 更新困难：如果库更新了，所有依赖该库的程序都需要重新编译和链接以使用新版本。

### 动态链接

 .so，动态链接库的地址：LD_LIBRARY_PATH，GCC默认为动态链接
 **定义**

  * 动态链接是在程序运行时将程序的模块和所需的库链接到一起的过程。
  * 在动态链接中，程序运行时所需的库被加载到内存中，而不是在编译时被合并到可执行文件中。

 **过程**

  * 在编译和链接程序时，只生成包含程序自身代码和对外部库的引用的可执行文件。
  * 当程序运行时，操作系统的动态链接器（如Linux中的ld.so）将程序所需的库加载到内存中，并将程序中的引用解析为动态库中的符号。

 **优点**

  * 节省空间：由于可执行文件只包含程序自身的代码和数据，因此通常较小。
  * 管理便捷：多个程序可以共享同一个动态库，节省了系统资源并方便了库的更新和维护。

 **缺点**

  * 运行时开销：程序运行时需要加载和解析动态库，可能会稍微降低启动速度。
  * 系统依赖：程序运行需要确保所依赖的动态库在系统中可用，否则可能会导致运行时错误。


## 加载

  * 在加载阶段，操作系统负责将可执行文件的内容加载到内存中，并为程序分配必要的资源。这个过程包括以下几个关键步骤：
    * 内存分配：操作系统会为程序分配内存空间，这个空间通常包括代码段、数据段、堆和栈等区域。代码段用于存储程序的指令，数据段用于存储静态变量和全局变量，堆用于动态分配内存，栈用于存储函数调用和局部变量。
    * 装载程序：操作系统会将可执行文件的内容从存储设备（如硬盘）中读取到内存中。这包括将程序的指令、全局变量的初始值等加载到相应的内存区域。
    * 地址重定位：在加载阶段，操作系统还会执行地址重定位的操作。由于程序可能会被加载到内存的不同位置，其中的地址引用需要被调整，确保程序能够正确地访问内存中的数据和指令。
    * 动态链接库加载：如果程序依赖于动态链接库（DLL），那么这些库也会在加载阶段被加载到内存中，并与程序进行链接。
  * 一旦加载完成，操作系统会将程序的控制权交给程序的入口点，即 main() 函数


### C++加载的内存模型

 **代码段**

  * 可执行文件中的代码被复制到代码段中
    * 只读，防止程序意外修改自身的代码
    * 共享，多个进程同时执行相同的程序，可以共享同一个代码段，节省内存

 **数据段**

  * 包含程序中的全局变量和静态变量，以及一些常量数据。
  * 在加载过程中，数据段被初始化并分配内存空间，以存储这些变量的值。
  * 数据段通常分为两部分：初始化的数据段（Initialized Data Segment）和未初始化的数据段（Uninitialized Data Segment，也称为BSS段）。
    * 初始化的数据段存储已经初始化的全局变量和静态变量的值
    * 未初始化的数据段则存储全局变量和静态变量的声明，但尚未被初始化的值。程序开始执行时将其初始化为零或空值。

 **堆**

  * 动态内存分配的区域，用于存放程序运行时动态分配的内存。
  * 在加载过程中，操作系统会为堆分配一块初始大小的内存空间，通常称为堆的起始地址。
  * 程序可以通过调用new和delete等动态内存管理函数来在堆上分配和释放内存，堆的大小可以根据程序的需要动态增长或缩小。

 **栈**

  * 栈是用于函数调用和局部变量存储的内存区域。
  * 在加载过程中，操作系统会为每个线程分配一块栈空间，用于存储函数调用时的参数、局部变量和函数调用的返回地址等信息。栈是一种先进后出（LIFO）的数据结构，函数调用时会将调用函数的参数和局部变量压入栈中，函数返回时会从栈中弹出这些数据。

### 加载中的初始化

 * 在C++中，加载时初始化主要涉及全局变量（数组或对象）和静态变量（数组或对象）。这些变量在程序加载到内存时就会被初始化。
   * 全局变量（数组或对象）在程序的任何部分都可见，它们的初始化在程序启动时完成，在main函数执行之前进行。

```c++
// 变量
int globalVar = 42; // 加载时初始化

// 数组
int arr[4] = {1,2,3,4}; // 加载时初始化

// 对象
class MyClass {
public:
    MyClass() {
        std::cout << "MyClass Constructor" << std::endl;
    }
};

MyClass globalObject; // 加载时初始化，构造函数在main之前调用
```

   * 静态变量（数组或对象）
     * 全局静态变量、命名空间作用域中的静态变量和类的静态成员变量：通常在加载时初始化。这些变量的作用域仅限于声明它们的文件。
     * 静态局部变量：
       * 如果初始化表达式是常量表达式（带const关键字），则在加载时初始化。
       * 否则，在第一次使用时初始化。

```c++
// 全局静态变量
static int staticGlobalVar = 10; // 加载时初始化

// 命名空间下的全局静态变量
namespace MyNamespace {
    static int staticVar = 10; // 命名空间作用域中的静态变量，在加载时初始化
}

// 类的静态成员变量
class MyClass {
public:
    static int staticMemberVar;
};

int MyClass::staticMemberVar = 300; // 加载时初始化

// 局部静态变量
void exampleFunction() {
    static const int staticLocalVar = 20; // 如果是常量表达式，加载时初始化
    static int staticconst = 10; // 加载时初始化
}

void func() {
    static int localStaticVar = someFunction(); // 第一次调用func时初始化
}

// 静态全局对象
class MyClass {
public:
    MyClass() {
        std::cout << "MyClass Constructor" << std::endl;
    }
};

static MyClass staticGlobalObject; // 加载时初始化，构造函数在main之前调用
```

   * 初始化列表或联合体：使用初始化列表初始化的全局或静态变量在加载时初始化，联合体同理

```c++
// struct
struct Data {
    int x;
    int y;
};

Data data = {1, 2}; // 加载时初始化

// union
union MyUnion {
    int a;
    float b;
};

MyUnion myUnion = { 1 }; // 加载时初始化
```

   * 外部库与自定义初始化
     * 有些外部库会在加载时初始化全局状态。这些初始化通常通过库的构造函数或初始化函数进行。
     * 使用自定义初始化函数：通过自定义初始化函数，程序员可以确保某些初始化在加载时完成。比如使用GCC的构造函数属性

```c++
// 外部库初始化
extern "C" void __attribute__((constructor)) myInitFunction() {
    // 加载时初始化代码
}

// 自定义初始化
void __attribute__((constructor)) initFunction() {
    // 加载时初始化代码
}
```

   * 常量表达式的初始化：
     * 对于局部静态常量来说，在加载时初始化
     * 对于编译时能确定的初始值的常量，会在编译期间进行初始化，是直接插入exe文件中
     * 对于某些需要运算得到的值，初始化在运行时进行



## 执行

在程序加载完成后，CPU 开始执行程序的指令。执行阶段包括以下几个关键步骤：

程序入口点：操作系统将程序的控制权转交给 main() 函数，程序从这里开始执行。

指令执行：CPU 按照程序中的指令序列执行操作。这些指令可以是算术运算、逻辑运算、内存读写操作等等。

程序状态维护：在执行过程中，操作系统会维护程序的状态，包括程序计数器（PC）的值、内存中的变量值、堆栈的状态等。

系统调用：如果程序需要操作系统提供的服务（如文件 I/O、网络通信等），它会通过系统调用来请求操作系统执行相应的操作。

异常处理：在执行过程中，如果出现了异常情况（如除零错误、内存访问越界等），操作系统会捕获并处理这些异常，以确保程序的正常执行。

一旦程序执行完成或者被中断，操作系统会释放程序占用的资源，并将控制权返回给操作系统的调度程序，继续执行其他任务。

## 阶段

 * 预编译
   * #define、#if、#ifdef、#ifndef、#undef、#endif、#else
 * 编译期
   * enum、struct、union、auto、decltype、friend、声明、全局static、constexpr、inline、全局变量、vtable
   * 第二步：编译期创建的对象
     * 需要使用动态初始化
     * 执行顺序：基类局部static -> 子类局部static -> 非静态代码 -> 派生类的基类构造(执行基类普通成员的初始化，按照基类对象声明顺序执行) -> 派生类的成员构造(按照成员声明顺序) -> 派生类构造(派生类普通成员初始化)（包括vptr）
   * 编译期析构
     * 执行顺序：派生类析构 -> 派生类成员类对象析构 -> 基类析构
 * 运行期
   * 运行期创建的对象
     * 执行顺序：基类局部static -> 子类局部static -> 非静态代码 -> 派生类的基类构造(执行基类普通成员的初始化，按照基类对象声明顺序执行) -> 派生类的成员构造(按照成员声明顺序) -> 派生类构造(派生类普通成员初始化)（包括vptr）
   * 运行期析构
     * 执行顺序：派生类析构 -> 派生类成员类对象析构 -> 基类析构
   * 运行期virtual


<!--more-->


## 动态联编和静态联编

 * 指计算机程序不同部分彼此关联，分为静态和动态
 * 静态联编是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差
 * 动态联编指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果
 * C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类的指针变量名->虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）

 **实现的条件**
  * 必须把动态联编的⾏为定义为类的虚函数；
  * 类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；
  * 必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数；


## 对象构建顺序

  1. 先执行base的static，再执行派生类static（按出现顺序）
  2. 非静态代码（成员方法，成员变量，成员代码块等）如果有类对象则按照顺序构建
  3. 构造函数
     1. 基类普通成员初始化、基类构造（按照基类在派生类中出现的顺序，而不是成员初始化顺序），如果对象有vptr，vptr不断被重定义
     2. 成员类对象构造函数（如果有多个成员类构造函数，调用顺序是对象在类中被声明的顺序）
     3. 派生类普通成员初始化、派生类构造

## 析构顺序

  1. 派生类析构
  2. 成员类对象析构
  3. 基类析构


## 何时需要初始化

 * 引用成员变量
 * const
 * 基类构造有一组参数
 * 成员构造有一组参数
 * 初始化顺序：按照成员声明顺序决定



## C++初始化

 **类型**
  * 编译初始化
  * 动态初始化

### 编译初始化

 * 静态初始化在程序加载的过程中完成
 * 包括全局变量初始化和constexpr类型的初始化
   * zero initialization 的变量会被保存在 bss 段
   * constexpr initialization 的变量则放在 data 段内
   * 其次全局类对象也是在编译器初始化。

### 动态初始化
 出现时机：出现在编译期和运行期的局部位置初始化
 * 动态初始化也叫运行时初始化
 * 需要经过函数调用才能完成的初始化、类初始化
   * 局部静态类对象的初始化
   * 局部静态变量的初始化
 * 动态初始化一般出现在

## 动态初始化中静态局部变量2个问题

### 线程安全问题

 **实现方法**
  * 一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起而不是跳过
    * 局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中。
    * 然后编译器会生成一个保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。
      * 它的最低的一个字节被用作相应静态变量是否已被初始化的标志
        * 若为 0 表示还未被初始化，否则表示已被初始化(if ((guard_for_bar & 0xff) == 0)判断)。 
      * __cxa_guard_acquire 实际上是一个加锁的过程，
        *  相应的 __cxa_guard_abort 和__cxa_guard_release 释放锁。

### 内存泄漏问题

 **原因**
  * 在局部作用域消失时，data区仍然保存其内存空间
  * 执行路径不明
    * 对于局部静态变量，构造和析构都取决于程序的执行顺序。程序的实际执行路径不可预知的
  * 关系不明
    * 局部静态变量分布在程序代码各处，彼此直接没有明显的关联，很容易让开发者忽略它们之间的这种关系

 **建议**
  * 减少使用局部静态变量




## 实例化

 **过程**
  * 分配内存空间
  * 执行构造

 **不可实例化的类**
  * 带有一个或以上virtual的函数的类
  * 工具类（直接通过static调用函数）

 **如何阻止实例化**
  * 包含纯虚函数
  * 构造函数私有

### 实例化中的变量初始化时机与顺序

 **时机**
 * 类中const初始化必须在构造函数初始化列表中初始化
 * 类中static初始化必须在类外初始化
 * 成员变量初始化顺序按照类中声明顺序，而构造函数初始化顺序按照成员变量在构造函数中位置决定

 **顺序**
 * 初始化base类中的static部分（按程序出现顺序初始化）
 * 初始化派生类中的static部分（按程序出现顺序初始化）
 * 初始化base类的普通成员变量和代码块，再执行父类的构造方法；
 * 初始化派生的普通成员变量和代码块，在执行子类的构造方法；



### 问题

***把异常完全封装在析构函数内部，决不让异常抛出函数之外***

***栈上的指针什么时候析构***

***.h .cpp .hpp 关系***

### 函数指针
 * 指向函数的指针变量。函数指针本身是一个指针变量，变量指向一个函数。
   * 有了这个指针，可以用这个指针变量调用函数
   * 除了调用外还可以做函数的参数


```c++
char * fun(char * p) {…}  // 指向char的指针
char * (*pf)(char * p);   // pf函数指针
pf = fun;                 // 函数指针指向函数
pf(p);                    // 调用
```

### bool、int、float、指针类型变量a与0的比较语句

```c++
if(!a) or if(a)

if (a ==0)

if(a <= 0.000001 && a >=-0.000001)

if(a != NULL ) or if(a == NULL)
```



## helloworld程序开始到打印到屏幕的过程
 * ⽤户告诉操作系统执⾏ HelloWorld 程序（通过键盘输⼊等）；
 * 操作系统：找到 HelloWorld 程序的相关信息，检查其类型是否是可执⾏⽂件；并通过程序⾸部信息，确定代码和数据在可执⾏⽂件中的位置并计算出对应的磁盘块地址；
 * 操作系统：创建⼀个新进程，将 HelloWorld 可执⾏⽂件映射到该进程结构，表示由该进程执⾏ HelloWorld程序；
 * 操作系统：为 HelloWorld 程序设置 cpu 上下⽂环境，并跳到程序开始处；
 * 执⾏ HelloWorld 程序的第⼀条指令，发⽣缺⻚异常；
 * 操作系统：分配⼀⻚物理内存，并将代码从磁盘读⼊内存，然后继续执⾏ HelloWorld 程序;
 * HelloWorld 程序执⾏ puts 函数（系统调⽤），在显示器上写⼀字符串;
 * 操作系统：找到要将字符串送往的显示设备，通常设备是由⼀个进程控制的，所以，操作
 * 系统将要写的字符串送给该进程;
 * 操作系统：控制设备的进程告诉设备的窗⼝系统，它要显示该字符串，窗⼝系统确定这是⼀个合法的操作，然后将字符串转换成像素，将像素写⼊设备的存储映像区;
 * 视频硬件将像素转换成显示器可接收和⼀组控制数据信号;
 * 显示器解释信号，激发液晶屏;



## printf实现原理

函数参数通过压入堆栈的方式来传递参数
而栈是从内存高地址向低地址生长，因此最后压栈的在堆栈指针的上方，printf第一个被找到的参数就是字符指针。函数通过判断字符串控制参数的个数来判断参数个数与数据类型，进而算出需要的堆栈指针偏移量


